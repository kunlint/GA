% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select.R
\name{select}
\alias{select}
\title{Select Variables for Regression}
\usage{
select(
  dataset,
  response,
  predictors = NULL,
  family = gaussian(),
  max_iter = 100,
  min_iter = 10,
  fitness_function = AIC,
  reltol = 1e-08,
  gen_size = 1.5,
  mutate_prob = 0.01,
  diversity_fact = 0.1,
  details = F,
  selection_mode = 1,
  generation_gap = 1,
  cross_point = 1,
  parallel = F,
  ...
)
}
\arguments{
\item{dataset}{A dataframe containing the response and the predictors.}

\item{response}{The name of the response in the dataset that we want to predict.}

\item{predictors}{The names of the predictors. If given, predictors will only
be chosen from the supplied names.}

\item{family}{Type of regression. Defaults to gaussian.}

\item{max_iter}{Maximum number of iterations to run. Defaults to \code{100}.}

\item{min_iter}{Minimum numbers of iterations to run. Defaults to \code{10}.}

\item{fitness_function}{Function to evaluate the fitted model. Defaults to
\code{AIC}. For user-provided function, it must be able to take an
\code{lm} or \code{glm} object and return a numeric value. The values
should be smaller for better models.}

\item{reltol}{Relative tolerance. Defaults to \code{1e-8}. If the relative
difference between the fitness scores of the best candidates in the current
generation and the previous generation is smaller than \code{reltol}, and
the genetic diversity is low, we stop and return the result.}

\item{gen_size}{Number to determine the number of candidates in each
generation. Defaults to 1.5. The generation size is \code{gen_size}
\code{*} \code{num_of_predictors}.}

\item{mutate_prob}{Probability of mutation. Defaults to \code{0.01}. Each
gene (predictor) mutate independently according to this probability.}

\item{diversity_fact}{A number in between \code{0} and \code{1} to decide
whether the diversity in the current generation is low. Defaults to
\code{0.1}, i.e., when the number of distinct candidates in the generation
is less than the maximum of \code{0.1} \code{*} \code{generation_size}
and \code{2}, we consider diversity is low.}

\item{details}{Whether to store the fitness scores along the way. Defaults to
False. If True, also plot the evolving fitness scores for all the generations.}

\item{selection_mode}{\code{1} or \code{2}. Defaults to \code{1}. If
\code{1}, we choose both parents according to the fitness scores
independently. If \code{2}, one of the parents is chosen according to the
fitness scores, and the other is chosen completely random.}

\item{generation_gap}{Ratio of update. Defaults to \code{1}, i.e., update every
subject in the generation when producing offspring. Must be a number
in between \code{0} and \code{1}.}

\item{cross_point}{Number of cut points to perform cross-over. Defaults to
\code{1}. Should not exceed  \code{num_of_predictors} \code{-} \code{1}.}

\item{parallel}{Whether to use parallel computation, using the R \code{future}
package. Defaults to False. If True, users should designate the number
of cores to use on their end using the \code{plan} function in the
\code{future} package.}

\item{...}{other arguments to pass to the R \code{glm}/\code{lm} function.}
}
\value{
A named list containing \code{iteration}, the number of iterations,
\code{best_cand}, a character vector containing the names of the best
predictors, \code{fitness_score}, the fitness score of the best predictors
(the negative value of \code{fitness_function} applying to the best
predictors), and \code{fit_scores_mat}, if \code{details} is \code{True},
this is the matrix of the fitness scores for all subjects in all
generations (each column is a generation). In some cases, it is possible
that the best candidate does not exist in the last generation, so
\code{best_so_far} returns the best candidate among all the generations.
}
\description{
\code{select} return the best set of predictors for a given response
}
\details{
This function uses a simple genetic algorithm to select the best predictors
for a given response, using the supplied fitness function, e.g., AIC or BIC
scores. Predictors are encoded in a binary fashion, where \code{1} means
including the predictor and \code{0} means excluding the predictor. Subjects
are grouped into generations, where each subject is a binary vector. In each
generation, parents are selected from the subjects according to their fitness
rank, and offspring are produced to generate the next generation. In later
generations, we can expect predictors (subjects) with good performance
persist, and the bad predictors are filtered out, such that we end up with a
good (heuristically speaking) set of predictors in the last generation.
}
\examples{
select(mtcars, "mpg")
select(mtcars, "am", family="binomial")
select(baseball, "y", generation_gap=0.5)
}
